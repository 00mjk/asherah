# appencryption-docs
Application Encryption SDK documentation covering background, features, and starting points for language implementations.

Table of Contents
=================

   * [Introduction](#introduction)
       * [Definitions](#definitions)
       * [Data Structures and Storage](#data-structures-and-storage)
   * [Getting Started](#getting-started)
   * [Further Reading](#further-reading)
   * [Supported Languages](#supported-languages)
       * [Feature Support](#feature-support)
   * [Current Status](#current-status)
   * [Contributing](#contributing)

## Introduction

The Application Encryption SDK provides advanced encryption techniques exposed via simple APIs for application-layer encryption.
Its goal is to provide an easy-to-use library which abstracts its internal complexity and provides rapid, frequent key rotation
with enterprise scale in mind.

Multiple layers of keys are used in conjunction with a technique known as "envelope encryption". Envelope encryption is a
practice where a key used to encrypt data is itself encrypted by a key and stored alongside the encrypted data, hence forming an
envelope structure. The master key used at the root of the key hierarchy is typically managed by a Hardware Security Module (HSM)
or Key Management Service (KMS).

The SDK generates cryptographically strong intermediate keys in the hierarchical model and manages their storage via a pluggable
backing datastore. The integration with a HSM or KMS provider for the root (master) key in the hierarchy is implemented using a
similar pluggable model. This allows for supporting a wide variety of datastores and cloud providers for different architectures.

The SDK provides implementations in multiple languages using native unmanaged interoperability mechanisms to securely manage and
cache internally-generated keys in off-heap protected memory. The combination of secure memory management and the hierarchical
key model's partitioning help minimize attack exposure in the event of compromise. Using the protected memory cache has an added
benefit of reducing interactions with external resources to improve latency and minimize incurred costs.


### Definitions

#### Common Encryption Terminology

The following common encryption terms will help establish the roles of the internals in the SDK.

* Data Encryption Key (DEK)
    * A key that is used to encrypt data
* Key Encryption Key (KEK)
    * A key that is used to encrypt another key (as opposed to data)
* Envelope Encryption
    * Process where data is encrypted with a DEK, the DEK is encrypted with a KEK, and the encrypted data and encrypted key are
      stored together
* Hardware Security Module (HSM)
    * A physical device which securely stores keys in a manner in which they cannot be extracted
* Key Management Service (KMS)
    * A managed service which provides secure and centralized key management and encryption functionality that is typically
      offered by a cloud provider.
* Master Key (MK)
    * Root key managed by an HSM or KMS

#### SDK Terminology

Below are common terms you will see throughout the SDK documentation. We'll show how these come together in more detail in the
[Data Structures and Storage](#data-structures-and-storage) section.

* System Key (SK)
    * A KEK generated by the SDK, which is encrypted by a KEK generated by the MK. Suggested partition scope is a service or subsystem
* Intermediate Key (IK)
    * A KEK generated by the SDK, which is encrypted by an SK. Suggested partition scope is a user or account
* Data Row Key (DRK)
    * A DEK generated by the SDK, which is encrypted by an IK and generated on every encrypt/write request
* Data Row Record (DRR)
    * Envelope containing data encrypted by the DRK and the encrypted DRK
* Envelope Key Record (EKR)
    * Internal data structure used to represent a SK, IK, or DRK. Consists of an encrypted key and metadata referencing the
      parent key in the key hierarchy used to encrypt it (i.e. its KEK)
* ParentKeyMeta
    * Metadata in EKR that references a parent key in the key hierarchy. Note that for SKs, this content may be embedded within
      the encrypted key content, depending on the KMS being used
* KeyManagementService
    * Represents a backing HSM or KMS implementation
* MetastorePersistence (aka Metastore or Metadata Persistence)
    * Represents a SDK-managed datastore implementation used to store SK and IK EKRs
* CryptoPolicy
    * Defines the policy used to manage internal behavior of the library, such as when to expire keys
* Secure Memory
    * Provides the unmanaged off-heap memory mechanisms that implement protected memory best practices
* Protected Memory Cache (aka Cache)
    * The location where the Application Encryption SDK stores decrypted keys using Secure Memory
* Data Persistence (aka Persistence)
    * Represents a user-managed datastore implementation used to store DRRs


### Data Structures and Storage

Add core envelope encryption structures, key hierarchy, storage, etc.

May be good place for showing very high level sequence diagram between user, library, metastore, KMS (putting all the high level concepts together)


## Getting Started

The basic use of the SDK proceeds in 3 steps:

 1. Create a session factory
 2. Create a session
 3. Use the session to accomplish the cryptographic task.
 
### Create a session factory
A session factory is required to generate encryption/decryption sessions. For simplicity, the session factory uses the
builder pattern, specifically a _step builder_. This ensures all required properties are set before a factory is built.

To obtain an instance of the builder, use the static factory method `newBuilder`. Once you have a builder, you can 
use the `withXXX` setter methods to configure the session factory properties.

Below is an example of a session factory that uses in-memory persistence and static key management.
``` java
AppEncryptionSessionFactory appEncryptionSessionFactory = AppEncryptionSessionFactory
    .newBuilder("myservice", "sample_code")
    .withMemoryPersistence() // in-memory metastore persistence only
    .withNeverExpiredCryptoPolicy()
    .withStaticKeyManagementService("secretmasterkey!") // hard-coded/static master key
    .build());
```
### Create a session
Use the factory to create a session. 
``` java
AppEncryption<byte[], byte[]> appEncryptionBytes = appEncryptionSessionFactory.getAppEncryptionBytes("shopper123");
```

The scope of a session is limited to a partition id, i.e. every partition id should have its own session. 

### Use the session to accomplish the cryptographic task

The SDK supports 2 usage patterns:

 1. Encrypt / Decrypt
 2. Load / Store

#### Encrypt / Decrypt
This usage style is similar to common encryption utilities where payloads are simply encrypted and
decrypted, and it is completely up to the calling application for storage responsibility.
``` java
string originalPayloadString = "mysupersecretpayload";
  // encrypt the payload 
byte[] dataRowRecordBytes = appEncryptionBytes.encrypt(originalPayloadString.getBytes(StandardCharsets.UTF_8));
  // decrypt the payload 
String decryptedPayloadString = new String(appEncryptionBytes.decrypt(newBytes), StandardCharsets.UTF_8);
```
#### Load / Store
This pattern uses a key-value/document storage model. An `AppEncryption` instance can accept a `Persistence`
implementation and hooks into its load and store calls.


Example `HashMap`-backed `Persistence` implementation:
``` java
Persistence dataPersistence = new Persistence<JSONObject>() {

    Map<String, JSONObject> mapPersistence = new HashMap<>();

    @Override 
    public Optional<JSONObject> load(String key) { 
    return Optional.ofNullable(mapPersistence.get(key)); 
    }

    @Override 
    public void store(String key, JSONObject value) { 
    mapPersistence.put(key, value); 
    } 
};
```
Putting it all together, an example end-to-end use of the store and load calls:
``` java
// Encrypts the payload, stores it in the dataPersistence and returns a look up key 
String persistenceKey = appEncryptionJson.store(originalPayload.toJsonObject(), dataPersistence);

// Uses the persistenceKey to look-up the payload in the dataPersistence, decrypts the payload if any and then returns it 
Optional<JSONObject> payload = appEncryptionJson.load(persistenceKey, dataPersistence);
```

## Further Reading

* [System requirements](SystemRequirements.md)
* [Key Management Service](KeyManagementService.md)
* [Metastore Persistence](Metastore.md)
* [Common APIs and Algorithm Internals](Internals.md)
* [Roadmap](ROADMAP.md)
* [FAQ](FAQ.md)

## Supported Languages

* [Java](languages/java/app-encryption)
* [.NET](languages/csharp/AppEncryption)
* Go (coming soon!)

### Feature Support

| Feature            | Java | .NET | Go  |
| ------------------ | ---- | ---- | --- |
| AWS KMS Support    | Yes  | Yes  | Yes |
| RDBMS Metastore    | Yes  | Yes  | Yes |
| DynamoDB Metastore | Yes  | Yes  | No  |


## Current Status

Capture high level state of various languages, etc.
